---
layout: post
title: Reading Android Notifications with custom RemoteViews
description: Using Reflection to read what you are not supposed to
tags: android remoteviews notificationlistenerservice reflection
github: home-assistant-camaps-fx-adapter
---

## Android Notifications and RemoteViews

Notifications on Android have seen countless changes through the years. 

## Observing notifications from other apps

Any incoming notification can be read by any app, as of Android 15, as long as the user gives permission. Therefore notifications should not contain sensitive data and instead be treated as public domain. This also affects content that may be displayed in a notification later on, like mails or SMS, but we will not delve deeper into this privacy concern at this point.

Notifications can be observed via [NotificationListenerService](https://developer.android.com/reference/android/service/notification/NotificationListenerService). This Android service has to be registered via the AndroidManifest and will then be started and called by the operating system.

```kotlin
<manifest>

    <uses-permission android:name="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"/>

    <application>

        <service
            android:name="<OurServiceClass>"
            android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">

            <intent-filter>
                <action android:name="android.service.notification.NotificationListenerService"/>
            </intent-filter>

            <meta-data
                android:name="android.service.notification.default_filter_types"
                android:value="conversations|alerting|ongoing|silent"/>

        </service>

    </application>

</manifest>
```

A NotificationListenerService will be called every time a new notification is being posted or updated in the status bar.

```kotlin
class MainService : NotificationListenerService() {

    override fun onNotificationPosted(statusBarNotification: StatusBarNotification?) {
        Log.d(TAG, "Notification posted: $statusBarNotification")
    }
}
```

Unfortunately the NotificationListenerService becomes somewhat unreliable during development. After a few deployments, you may experience a NotificationListenerService that stops working and will not be created, started or notified about incoming notifications anymore. This has been a known issue for several years now which has been reported to Google but has yet to be fixed (see [issuetracker.google.com/issues/75414169](https://issuetracker.google.com/issues/75414169)). You can workaround this by restarting the device or, allegedly, by withdrawing and granting the notification permission again (see [this comment on stackoverflow](https://stackoverflow.com/a/37081128/3269827)). The latter did not work for me, so I had to restart devices every other hour.

## Reading notification contents

NotificationListenerService's `onNotificationPosted` is being called with every new or updated notification. Its parameter, a [StatusBarNotification](https://developer.android.com/reference/android/service/notification/StatusBarNotification), and its child, a [Notification](https://developer.android.com/reference/android/app/Notification), expose everything the user can see and do with a notification. Basic notifications contain pre-determined properties like a title, summary or icon. More complex or, in this case, sensitive notifications use [RemoteViews](https://developer.android.com/reference/android/widget/RemoteViews) to render custom views.

## Reading RemoteViews

TODO: Screenshot of debugger view with expanded RemoteViews

RemoteViews do not expose their contents, so we use reflection to read their internals. The debugger helps us identifying the properties we need to read data from the custom view. With this information in mind, we forge a path from the `RemoteViews` to `mActions`, a list of pairs for every method that can be called and its latest value.

We access `mActions` by retrieving RemoteViews' members via `KClass.memberProperties`, searching for the one with the right name, making it accessible (in order to call this internal property) and casting the result to a list of wildcards.

```kotlin
fun getRemoteViewActions(from: RemoteViews): List<Pair<String, Any?>> {
    val actionsProperty = RemoteViews::class.memberProperties
        .firstOrNull { it.name == "mActions" }
        ?: return emptyList()
    actionsProperty.isAccessible = true
    val actions = actionsProperty.get(from) as? ArrayList<*> 
        ?: return emptyList()
    return actions.mapNotNull(::getRemoteViewAction)
}
```

We then iterate over this list of actions and access every entry's method name (`mMethodName`) and value (`mValue`) via reflection like before.

```kotlin
fun getRemoteViewAction(from: Any): Pair<String, Any?>? {
    val memberProperties = from::class.memberProperties

    val methodNameProperty = memberProperties
        .firstOrNull { it.name == "mMethodName" } 
        ?: return null
    methodNameProperty.isAccessible = true
    val methodName = methodNameProperty.getter.call(from) as? String 
        ?: return null

    val valueProperty = memberProperties
        .firstOrNull { it.name == "mValue" } 
        ?: return null
    valueProperty.isAccessible = true
    val value = valueProperty.getter.call(from)

    return methodName to value
}
```

The method names and values can then be filtered to only read those of interest. For example we are looking for a custom view that displays a floating point number. Therefore we filter for actions that set a text (`methodName == "setText"`) to a number (`(value as? String)?.toFloatOrNull()`).

```
val remoteViewActions = getRemoteViewActions(remoteViews)
val setTextActions = remoteViewActions.filter { it.methodName == "setText" }
val number = setTextActions.mapNotNull { (it.value as? String)?.toFloatOrNull() }.firstOrNull()
```

Now we have access to the number in the notification's custom view.

## Breaking changes

As neat as this approach is, it is also fragile and may break at any given time due to changes outside of our reach: Updates to the CamAPS FX app may change the view that is being injected into the RemoteViews we are reading from. Updates to the operating system may change the RemoteViews API. This happened during development with Android 15 which renamed properties TODO according to the hungarian notation (why though?).