---
layout: post
title: Reading Android Notifications with custom RemoteViews
description: Using Reflection to read what you are not supposed to
tags: android remoteviews notificationlistenerservice reflection
github: home-assistant-camaps-fx-adapter
---

## Android Notifications and RemoteViews

Notifications on Android have seen countless changes through the years. 

## Observing notifications from other apps

Any incoming notification can be read by any app, as of Android 15, as long as the user gives permission. Therefore notifications should not contain sensitive data and instead be treated as public domain. This also affects content that may be displayed in a notification later on, like mails or SMS, but we will not delve deeper into this privacy concern at this point.

Notifications can be observed via [NotificationListenerService](https://developer.android.com/reference/android/service/notification/NotificationListenerService). This Android service has to be registered via the AndroidManifest and will then be started and called by the operating system.

```kotlin
<manifest>

    <uses-permission android:name="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"/>

    <application>

        <service
            android:name="<OurServiceClass>"
            android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">

            <intent-filter>
                <action android:name="android.service.notification.NotificationListenerService"/>
            </intent-filter>

            <meta-data
                android:name="android.service.notification.default_filter_types"
                android:value="conversations|alerting|ongoing|silent"/>

        </service>

    </application>

</manifest>
```

A NotificationListenerService will be called every time a new notification is being posted or updated in the status bar.

```kotlin
class MainService : NotificationListenerService() {

    override fun onNotificationPosted(statusBarNotification: StatusBarNotification?) {
        Log.d(TAG, "Notification posted: $statusBarNotification")
    }
}
```

Unfortunately the NotificationListenerService becomes somewhat unreliable during development. After a few deployments, you may experience a NotificationListenerService that stops working and will not be created, started or notified about incoming notifications anymore. This has been a known issue for several years now which has been reported to Google but has yet to be fixed (see [issuetracker.google.com/issues/75414169](https://issuetracker.google.com/issues/75414169)). You can workaround this by restarting the device or, allegedly, by withdrawing and granting the notification permission again (see [this comment on stackoverflow](https://stackoverflow.com/a/37081128/3269827)). The latter did not work for me, so I had to restart devices every other hour.

## Reading notification contents

NotificationListenerService's `onNotificationPosted` is being called with every new or updated notification. Its parameter, a [StatusBarNotification](https://developer.android.com/reference/android/service/notification/StatusBarNotification), and its child, a [Notification](https://developer.android.com/reference/android/app/Notification), expose everything the user can see and do with a notification. Basic notifications contain pre-determined properties like a title, summary or icon. More complex or, in this case, sensitive notifications use [RemoteViews](https://developer.android.com/reference/android/widget/RemoteViews) to render custom views.

## Reading RemoteViews

TODO: Screenshot of debugger view with expanded RemoteViews

RemoteViews do not expose their contents, so we use reflection to read their internal data. In order to find out which data , we analyze the data hierarchy using the debugger.

We can see that the `RemoteViews` objects consists of 

```kotlin
fun getRemoteViewActions(from: RemoteViews): List<Pair<String, Any?>> {
    val actionsProperty = RemoteViews::class.memberProperties
        .firstOrNull { it.name == "mActions" }
        ?: return emptyList()
    actionsProperty.isAccessible = true
    val actions = actionsProperty.get(from) as? ArrayList<*> 
        ?: return emptyList()
    return actions.mapNotNull(::getRemoteViewAction)
}
```

`getRemoteViewAction` accesses internal properties of the RemoteViews' actions to read their method name and value.

```kotlin
fun getRemoteViewAction(from: Any): Pair<String, Any?>? {
    val memberProperties = from::class.memberProperties

    val methodNameProperty = memberProperties
        .firstOrNull { it.name == "mMethodName" } 
        ?: return null
    methodNameProperty.isAccessible = true
    val methodName = methodNameProperty.getter.call(from) as? String 
        ?: return null

    val valueProperty = memberProperties
        .firstOrNull { it.name == "mValue" } 
        ?: return null
    valueProperty.isAccessible = true
    val value = valueProperty.getter.call(from)

    return methodName to value
}
```

The method names and values can then be filtered to only read those we are interested in. 

In our example we are looking for the custom view that displays a floating point number. So we filter for actions that set a text in the RemoteViews to a number.

```
val remoteViewActions = getRemoteViewActions(remoteViews)
val setTextActions = remoteViewActions.filter { it.methodName == "setText" }
val number = setTextActions.mapNotNull { (it.value as? String)?.toFloatOrNull() }.firstOrNull()
```

This extracts the number from the notification and we are free to .

## Breaking changes

As neat as this approach is, it is also fragile and may break at any given time due to changes outside of our reach: Updates to the CamAPS FX app may change the view that is being injected into the RemoteViews we are reading from. Updates to the operating system may change the RemoteViews API. This happened during development with Android 15 which renamed properties TODO according to the hungarian notation (why though?).